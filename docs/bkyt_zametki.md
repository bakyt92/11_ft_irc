Заметки по книге 

Два типа сокетов

**1. Stream sockets**
Потоковые сокеты это надёжные подключаемые двунаправленные потоки связи. Если вы отправите в сокет два послания в порядке “1, 2”, то на другой стороне они также появятся в порядке “1, 2”. Они также будут свободными от ошибок (error-free) - telnet приложения, HTTP протокол.

_Как потоковые сокеты достигают столь высокого качества передачи данных? Они
используют протокол, называемый “The Transmission Control Protocol”, иначе известный
как “TCP” (см. RFC 793 с полной информацией по TCP). TCP обеспечивает появление 7
ваших данных последовательно и без ошибок. Может быть ранее вы встречали “TCP” как
первую часть “TCP/IP”, где “IP” означает “Internet Protocol” (см. RFC 791 ). IP изначально 8
работает с Интернет маршрутизацией и обычно не отвечает за целостность данных._

**2. Datagram sockets** - Дейтаграммные сокеты иногда называют “неподключаемыми” (без установки логического соединения), хотя если очень хочется их можно подключить connect()-ом. (См. ниже). Они в основном используют UDP (User Datagram Protocol) - tftp (ftp protocol) / dhcpcd (DHCP client).

**Инкапсуляция** производится на разных уровнях 
![image](https://github.com/bakyt92/11_ft_irc/assets/40731866/4e6e973f-381f-4b17-8ff6-d91cee75a4cd)

- в первую очередь приложение заполняет специальную структуру данных, в которой указывает информацию о получателе (сетевой протокол, IP-адрес, порт UDP);
- передаёт сообщение, его длину и структуру с информацией о получателе обработчику протокола UDP (транспортный уровень);
- обработчик UDP формирует датаграмму, в которой в качестве данных выступает сообщение, а в заголовках находится UDP-порт получателя (а также другие данные);
- обработчик UDP передаёт сформированную датаграмму обработчику IP (сетевой уровень);
- обработчик IP рассматривает переданную UDP датаграмму как данные и предваряет их своим заголовком (в котором, в частности, находится IP-адрес получателя, взятый из той же структуры данных приложения, и номер верхнего протокола);
полученный пакет обработчик IP передаёт на канальный уровень, который опять-таки рассматривает данный пакет как «сырые» данные;
- обработчик канального уровня, аналогично предыдущим обработчикам, добавляет в начало свой заголовок (в котором так же указывается номер протокола верхнего уровня, в нашем случае это 0x0800(IP)) и, в большинстве случаев, добавляет конечную контрольную сумму, тем самым формируя кадр;
- далее полученный кадр передаётся на физический уровень, который осуществляет преобразование битов в электрические или оптические сигналы и посылает их в среду передачи.

Порядок байтов может различаться между сетью и хостом. 
Для преобразования порядка байтов могут использоваться следующие команды:
- htons() host to network short
- htonl() host to network long
- ntohs() network to host short
- ntohl() network to host long

Дескриптор сокета носит тип int. 

Структура для подготовки адресных стрктур сокета для дальнейшего использования 

**struct addrinfo {
 int ai_flags; // AI_PASSIVE, AI_CANONNAME, т.д.
 int ai_family; // AF_INET, AF_INET6, AF_UNSPEC
 int ai_socktype; // SOCK_STREAM, SOCK_DGRAM
 int ai_protocol; // используйте 0 для"any"
 size_t ai_addrlen; // размер ai_addr в байтах
 struct sockaddr *ai_addr; // struct sockaddr_in или _in6
 char *ai_canonname; // полное каноническое имя хоста
 struct addrinfo *ai_next; // связанный список, следующий
 };**



