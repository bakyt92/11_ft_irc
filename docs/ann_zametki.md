## Internet Relay Chat Protocol - RFC 1459
https://www.lissyara.su/doc/rfc/rfc1459/  
### Сообщения
* Серверы и клиенты создают сообщения на которые можно ответить, а можно и нет. Если сообщение содержит правильные команды, как описано в предыдущем разделе, клиенту следует ответить как полагается, но это не означает, что всегда можно дождаться ответа.
* Каждое IRC-сообщение может содержать до трех главных частей: префикс (опционально), команду и параметры команды (которых может быть до 15).
  + Префикс, команда и все параметры разделены одним (или более) символом пробела (' ').
  + Префикс обозначается одним символом, стоящим вначале (':', 0x3b), который должен быть первым символом в сообщении. Между префиксом и двоеточием не должно быть никаких пробелов. Префикс используется серверами для обозначения источника появления сообщения.
  + Если префикс сообщения утерян, то за источник сообщения берут соединение, с которого было получено сообщение. Клиентам не следует пользоваться префиксами при отсылке сообщения; если они начнут использовать префиксы, то приниматься будут только правильные и только с зарегистрированных никнеймов. Если исходные идентификаторы префиксов не будет найдены в серверных базах данных, или если они зарегистрированы с различных линков, то сервер будет игнорировать сообщение.
* Команда должна содержать правильную IRC-команду или трехзначное число, представленное в ASCII-тексте.
* IRC-сообщения всегда выглядят как строки символов, заканчивающихся парой символов CR-LF и длиной строки, не превышающей 512 символов (в 512 входят CR-LF). Так что, максимальная длина строки для команд и параметров - 510 символов.
* Перенос строки невозможен.

## `poll()` syscall
* `POLLIN` = any readable data available
  + If you use POLLIN only, poll() will return if there is data or urgent data to read
* `POLLPRI` = there is urgent data to read
  + urgent data:
    - tcp's out-of-band data. In TCP frame header, there is a flag `urg_data`, it  means this frame has higher priority to delivery
    - Once kernel received a urg_data maked frame, it set a POLLPRI flag
  + If you use POLLPRI only, poll() will return only if there is urgent data to read, but ignore normal data
* the struct `pollfd`
  + for monitoring file descriptors for I/O events
  + it’s commonly employed with the `poll()` to perform multiplexed I/O => efficiently wait for events on multiple file descriptors simultaneously without having to resort to blocking I/O operations


## Заметки Бориса
*. Client - добавить _fd с геттером
*. Поковырять скорость обработки команд в процессоре (по ощущениям каждая команда около 1с обрабатывается).
     Убедиться, что Response не создается повторно, оптимизировать поиск и вызов классов команд.
   Со скоростью отработки команды все ок (до 100 микросекунд)

* Изменить порядок обработки авторизации клиента - при неверном пароле дальше не обрабатывать команды.
   Это в случае, если приходят команды пачкой /PASS/NICK/USER
   По идее если клиент подключился, у него статус isActive = false пока не введет правильный пароль. В таком статусе
   никакие команды от него приниматься не должны.
* DONE ClientCollection.cpp, line 51:
   if (_it != _clientMap.end()) заменить на if (_it == _clientMap.end()) return (1);
*. Заменить _kernel.set -> _kernel._set и поменять везде в классах ссылки
*. NEED_INFO Нужен метод Client* Channel::findClient();
*. Добавить в Client flag +v
*. Переделать Response::getResponse для случая если код 0, не добавляем code и не добавляем _reply[code]
*. Добавить Client.AwayMessage()
*. Добавить назначение оператора в QUIT
*. (method isChanopNick() ?? )Операторов Channel надо сделать вектором и добавить метод поиска клиента среди операторов
